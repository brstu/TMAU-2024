<p align="center">Министерство образования Республики Беларусь</p>
<p align="center">Учреждение образования</p>
<p align="center">«Брестский государственный технический университет»</p>
<p align="center">Кафедра ИИТ</p>
<br><br><br><br>
<p align="center">Лабораторная работа №2</p>
<p align="center">По дисциплине: «ТИМАУ»</p>
<br><br><br>
<p align="right">Выполнил</p>
<p align="right">Студент 3-го курса</p>
<p align="right">Группы АС-64</p>
<p align="right">Попов А.С.</p>
<p align="right">Проверила</p>
<p align="right">Ситковец Я.С.</p>
<br><br><br>
<p align="center">Брест 2024</p>

---

## Описание

Этот проект реализует моделирование ПИД-регулятора (пропорционально-интегрально-дифференциальный регулятор) для управления системой. В программе используется класс **PIDController**, который выполняет расчет управляющего сигнала на основе входных данных: целевого значения (setpoint) и текущего значения (actual_value). 

Программа предназначена для демонстрации работы ПИД-регулятора и его настройки с помощью трех основных параметров: пропорционального (P), интегрального (I) и дифференциального (D) коэффициентов.

## Ход работы программы

1. **Инициализация ПИД-регулятора**
    В начале работы программы создается объект класса `PIDController` с начальными значениями коэффициентов PID: `kp`, `ki`, и `kd`. Эти значения определяют поведение регулятора, например:
    - `kp` — коэффициент пропорциональности, который отвечает за скорость отклика системы.
    - `ki` — коэффициент интеграции, который учитывает накопленную ошибку и устраняет смещение.
    - `kd` — коэффициент дифференциации, который помогает уменьшить колебания и снижает избыточное управление.

2. **Установка целевого значения (setpoint) и текущего значения (actual_value)**
    - `setpoint` — это желаемое значение, к которому система должна стремиться.
    - `actual_value` — это текущее значение, которое может изменяться в ходе работы программы.

3. **Обновление управляющего сигнала**
    Программа работает в цикле, в котором на каждом шаге вызывается метод `update()` для вычисления управляющего сигнала. Метод принимает два аргумента:
    - `setpoint` — целевое значение.
    - `actual_value` — текущее значение.

    Метод `update()` вычисляет ошибку между целевым и текущим значением, накапливает её (интегрирует) и вычисляет производную ошибки для получения управляющего сигнала. Этот сигнал используется для коррекции состояния системы.

4. **Имитация системы**
    После того как вычислен управляющий сигнал, программа использует его для корректировки `actual_value`. В реальной системе это могло бы быть изменение состояния физического устройства, но в нашем случае это просто прибавление управляющего сигнала к текущему значению.

5. **Завершение работы программы**
    Программа продолжает работать до тех пор, пока разница между целевым и текущим значением не станет достаточно малой (например, меньше 0.1). После этого программа завершает выполнение.

## Пример работы

Предположим, что мы хотим, чтобы система пришла к значению 100.0. На старте текущие данные равны 90.0. Программа будет постепенно корректировать значение с помощью управляющего сигнала, пока оно не станет достаточно близким к целевому.

Пример кода:

```cpp
#include "pid_controller.h"
#include <iostream>

int main() {
    // Инициализация ПИД-регулятора с коэффициентами
    PIDController pid(1.0, 0.1, 0.01);
    
    // Установка целевого значения и текущего значения
    double setpoint = 100.0; // Целевое значение
    double actual_value = 90.0; // Текущее значение

    // Работа в цикле до достижения целевого значения
    while (true) {
        double control_signal = pid.update(setpoint, actual_value);  // Обновление управляющего сигнала
        std::cout << "Control Signal: " << control_signal << std::endl;
        
        // Симуляция реакции системы
        actual_value += control_signal;
        
        // Условие завершения, когда текущее значение достаточно близко к целевому
        if (abs(setpoint - actual_value) < 0.1) break;
    }

    return 0;
}
```

### Ожидаемый результат:
В процессе работы программы на экране будет выводиться управляющий сигнал, который корректирует текущее значение системы, пока оно не станет достаточно близким к целевому значению.

## Сборка и запуск

Для компиляции и запуска программы используйте следующий набор команд:

1. Скомпилируйте исходные файлы:

```bash
g++ -o pid_controller pid_controller.cpp main.cpp
```

2. Запустите программу:

```bash
./Task02
```